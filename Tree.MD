# ğŸŒ³ algorithms core Library - Complete Structure Tree

## ğŸ“š Library Overview
```
algorithms_core/
â”œâ”€â”€ ğŸ“– Documentation & Configuration
â”‚   â”œâ”€â”€ README.md
â”‚   â”œâ”€â”€ CHANGELOG.md
â”‚   â”œâ”€â”€ LICENSE
â”‚   â”œâ”€â”€ pubspec.yaml
â”‚   â””â”€â”€ analysis_options.yaml
â”œâ”€â”€ ğŸ¯ Core Library (lib/)
â”‚   â”œâ”€â”€ algorithms_core.dart (Main export file)
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ algorithms_core_base.dart
â”œâ”€â”€ ğŸ”§ Algorithms by Category
â”‚   â”œâ”€â”€ ğŸŒ² Tree Algorithms (NEW)
â”‚   â”œâ”€â”€ ğŸ”— Linked List Algorithms (NEW)
â”‚   â”œâ”€â”€ ğŸ“Š List Algorithms
â”‚   â”œâ”€â”€ ğŸ—ºï¸ Map Algorithms
â”‚   â”œâ”€â”€ ğŸ” Set Algorithms
â”‚   â”œâ”€â”€ ğŸ“ String Algorithms
â”‚   â””â”€â”€ ğŸ•¸ï¸ Graph Algorithms
â”œâ”€â”€ ğŸ§ª Test Suite (test/)
â”œâ”€â”€ ğŸ“š Examples (example/)
â””â”€â”€ ğŸ¨ Assets (logo/)
```

## ğŸŒ² Tree Algorithms (NEW)
```
Tree Algorithms/
â”œâ”€â”€ ğŸŒ³ Binary Tree Node
â”‚   â””â”€â”€ BinaryTreeNode<T> (Generic tree node with left, right, value)
â”œâ”€â”€ ğŸ”„ Tree Traversals
â”‚   â”œâ”€â”€ inorderTraversal<T> (Left â†’ Root â†’ Right)
â”‚   â”œâ”€â”€ preorderTraversal<T> (Root â†’ Left â†’ Right)
â”‚   â””â”€â”€ postorderTraversal<T> (Left â†’ Right â†’ Root)
â”œâ”€â”€ ğŸ“Š Level Order Traversal
â”‚   â””â”€â”€ levelOrderTraversal<T> (BFS - Breadth First Search)
â”œâ”€â”€ ğŸ“ Tree Depth
â”‚   â””â”€â”€ treeDepth<T> (Height calculation)
â”œâ”€â”€ ğŸ”„ Tree Inversion
â”‚   â””â”€â”€ invertTree<T> (Mirror tree)
â”œâ”€â”€ ğŸ”— Lowest Common Ancestor
â”‚   â””â”€â”€ lowestCommonAncestor<T> (LCA algorithm)
â”œâ”€â”€ âœ… BST Validation
â”‚   â””â”€â”€ validateBST<T extends Comparable> (Binary Search Tree validation)
â”œâ”€â”€ ğŸ“ Tree Diameter
â”‚   â””â”€â”€ treeDiameter<T> (Longest path between any two nodes)
â”œâ”€â”€ âš–ï¸ Balanced Tree Check
â”‚   â””â”€â”€ isBalanced<T> (Height-balanced tree check)
â”œâ”€â”€ ğŸ’¾ Tree Serialization
â”‚   â”œâ”€â”€ serializeTree<T> (Tree to string)
â”‚   â””â”€â”€ deserializeTree<T> (String to tree)
â””â”€â”€ ğŸ Zigzag Traversal
    â””â”€â”€ zigzagTraversal<T> (Alternating level order)
```

## ğŸ”— Linked List Algorithms (NEW)
```
Linked List Algorithms/
â”œâ”€â”€ ğŸ”— Linked List Node
â”‚   â””â”€â”€ LinkedListNode<T> (Generic singly linked list node)
â”œâ”€â”€ ğŸ”„ Doubly Linked List Node
â”‚   â””â”€â”€ DoublyLinkedListNode<T> (Generic doubly linked list node)
â”œâ”€â”€ ğŸ“ Insert/Delete Operations
â”‚   â”œâ”€â”€ insertAtPosition<T> (Insert at specific position)
â”‚   â”œâ”€â”€ deleteAtPosition<T> (Delete at specific position)
â”‚   â”œâ”€â”€ insertAfterValue<T> (Insert after specific value)
â”‚   â””â”€â”€ deleteByValue<T> (Delete by value)
â”œâ”€â”€ ğŸ”„ Reverse Operations
â”‚   â”œâ”€â”€ reverseLinkedList<T> (Iterative reverse)
â”‚   â”œâ”€â”€ reverseLinkedListRecursive<T> (Recursive reverse)
â”‚   â”œâ”€â”€ reverseDoublyLinkedList<T> (Doubly linked list reverse)
â”‚   â”œâ”€â”€ reverseInGroups<T> (Reverse in groups of K)
â”‚   â””â”€â”€ reverseBetween<T> (Reverse between positions)
â”œâ”€â”€ ğŸ” Cycle Detection
â”‚   â”œâ”€â”€ detectCycle<T> (Floyd's Tortoise and Hare)
â”‚   â”œâ”€â”€ findCycleStart<T> (Find cycle start node)
â”‚   â”œâ”€â”€ getCycleLength<T> (Calculate cycle length)
â”‚   â”œâ”€â”€ detectCycleWithHashSet<T> (Hash set approach)
â”‚   â””â”€â”€ removeCycle<T> (Remove cycle from list)
â”œâ”€â”€ ğŸ”— Merge Operations
â”‚   â”œâ”€â”€ mergeSortedLists<T extends Comparable> (Merge two sorted lists)
â”‚   â”œâ”€â”€ mergeSortedListsRecursive<T extends Comparable> (Recursive merge)
â”‚   â”œâ”€â”€ mergeKSortedLists<T extends Comparable> (Merge K sorted lists)
â”‚   â”œâ”€â”€ mergeSortedListsInPlace<T extends Comparable> (In-place merge)
â”‚   â””â”€â”€ mergeSortedListsWithComparator<T> (Merge with custom comparator)
â”œâ”€â”€ ğŸ—‘ï¸ Remove Operations
â”‚   â”œâ”€â”€ removeNthFromEnd<T> (Two-pointer approach)
â”‚   â”œâ”€â”€ removeNthFromEndSinglePass<T> (Single pass)
â”‚   â”œâ”€â”€ removeNthFromEndRecursive<T> (Recursive approach)
â”‚   â””â”€â”€ removeNthFromEndWithReturn<T> (With return value)
â”œâ”€â”€ âœ… Palindrome Check
â”‚   â”œâ”€â”€ isPalindrome<T> (Two-pointer approach)
â”‚   â”œâ”€â”€ isPalindromeWithStack<T> (Stack approach)
â”‚   â”œâ”€â”€ isPalindromeRecursive<T> (Recursive approach)
â”‚   â””â”€â”€ isPalindromeWithArray<T> (Array approach)
â””â”€â”€ ğŸ”— Intersection Operations
    â”œâ”€â”€ getIntersectionNode<T> (Length difference approach)
    â”œâ”€â”€ getIntersectionNodeWithHashSet<T> (Hash set approach)
    â”œâ”€â”€ getIntersectionNodeTwoPointer<T> (Two-pointer approach)
    â”œâ”€â”€ getIntersectionNodeOptimized<T> (Optimized approach)
    â””â”€â”€ getIntersectionNodeWithInfo<T> (With additional info)
```

## ğŸ“Š List Algorithms
```
List Algorithms/
â”œâ”€â”€ ğŸ” Search Algorithms
â”‚   â”œâ”€â”€ linearSearch<T> (Linear search)
â”‚   â”œâ”€â”€ binarySearch<T extends Comparable> (Binary search)
â”‚   â””â”€â”€ findDuplicates<T> (Find duplicate elements)
â”œâ”€â”€ ğŸ“Š Sorting Algorithms
â”‚   â”œâ”€â”€ bubbleSort<T extends Comparable> (Bubble sort)
â”‚   â”œâ”€â”€ selectionSort<T extends Comparable> (Selection sort)
â”‚   â”œâ”€â”€ insertionSort<T extends Comparable> (Insertion sort)
â”‚   â”œâ”€â”€ mergeSort<T extends Comparable> (Merge sort)
â”‚   â”œâ”€â”€ quickSort<T extends Comparable> (Quick sort)
â”‚   â””â”€â”€ countingSort(List<int>) (Counting sort)
â”œâ”€â”€ ğŸ”„ Array Operations
â”‚   â”œâ”€â”€ reverseList<T> (Reverse array)
â”‚   â”œâ”€â”€ rotateArrayRight<T> (Rotate array right)
â”‚   â”œâ”€â”€ removeDuplicates<T> (Remove duplicates)
â”‚   â””â”€â”€ findMaxMin<T extends Comparable> (Find max and min)
â”œâ”€â”€ ğŸ“ˆ Subarray Operations
â”‚   â”œâ”€â”€ averageSubarray<T extends num> (Average of subarrays)
â”‚   â”œâ”€â”€ kadanesAlgorithm<T extends num> (Maximum subarray sum)
â”‚   â”œâ”€â”€ maxSumSubarrayOfSizeK<T extends num> (Max sum of size K)
â”‚   â”œâ”€â”€ minSum<T extends num> (Minimum sum subarray of size K)
â”‚   â””â”€â”€ prefixSum<T extends num> (Prefix sum array)
â””â”€â”€ ğŸ” Special Operations
    â””â”€â”€ twoSumSorted<T extends Comparable> (Two sum in sorted array)
```

## ğŸ—ºï¸ Map Algorithms
```
Map Algorithms/
â”œâ”€â”€ ğŸ” Search & Check Operations
â”‚   â”œâ”€â”€ twoSum<T> (Find two numbers that sum to target)
â”‚   â”œâ”€â”€ anagramChecker<T> (Check if two maps are anagrams)
â”‚   â”œâ”€â”€ firstNonRepeatedElement<T> (Find first non-repeated element)
â”‚   â””â”€â”€ mostFrequentElement<T> (Find most frequent element)
â”œâ”€â”€ ğŸ“Š Frequency Operations
â”‚   â”œâ”€â”€ frequencyCount<T> (Count frequency of elements)
â”‚   â”œâ”€â”€ topKFrequent<T> (Find top K frequent elements)
â”‚   â””â”€â”€ isFrequencyUnique<T> (Check if frequencies are unique)
â”œâ”€â”€ ğŸ”„ Grouping & Organization
â”‚   â”œâ”€â”€ groupByKey<T, K> (Group elements by key)
â”‚   â””â”€â”€ lengthOfLongestSubstring<T> (Longest substring without repeating)
â””â”€â”€ ğŸ’¾ Cache Operations
    â””â”€â”€ LRUCache<K, V> (Least Recently Used cache)
```

## ğŸ” Set Algorithms
```
Set Algorithms/
â”œâ”€â”€ ğŸ” Check Operations
â”‚   â”œâ”€â”€ hasDuplicates<T> (Check for duplicates)
â”‚   â”œâ”€â”€ hasTwoSum<T extends num> (Check if two sum exists)
â”‚   â””â”€â”€ hasUniqueWindow<T> (Check for unique window)
â”œâ”€â”€ ğŸ”„ Set Operations
â”‚   â”œâ”€â”€ findIntersection<T> (Find intersection of sets)
â”‚   â”œâ”€â”€ setDifference<T> (Find difference between sets)
â”‚   â””â”€â”€ isFrequencyUnique<T> (Check if frequencies are unique)
â””â”€â”€ ğŸ”— Disjoint Set
    â””â”€â”€ DisjointSet<T> (Union-Find data structure)
```

## ğŸ“ String Algorithms
```
String Algorithms/
â”œâ”€â”€ ğŸ” Search Algorithms
â”‚   â”œâ”€â”€ bruteForceSearch(String, String) (Brute force string search)
â”‚   â”œâ”€â”€ kmpSearch(String, String) (Knuth-Morris-Pratt algorithm)
â”‚   â””â”€â”€ rabinKarpSearch(String, String) (Rabin-Karp algorithm)
â”œâ”€â”€ ğŸ”„ String Operations
â”‚   â”œâ”€â”€ reverseString(String) (Reverse string)
â”‚   â”œâ”€â”€ countVowelsConsonants(String) (Count vowels and consonants)
â”‚   â””â”€â”€ stringCompression(String) (Compress string)
â”œâ”€â”€ ğŸ” Check Operations
â”‚   â”œâ”€â”€ palindromeChecker(String) (Check if palindrome)
â”‚   â””â”€â”€ anagramChecker<T> (Check if anagrams)
â”œâ”€â”€ ğŸ“ String Analysis
â”‚   â”œâ”€â”€ longestCommonPrefix(List<String>) (Longest common prefix)
â”‚   â”œâ”€â”€ longestPalindromicSubstring(String) (Longest palindromic substring)
â”‚   â””â”€â”€ editDistance(String, String) (Edit distance calculation)
```

## ğŸ•¸ï¸ Graph Algorithms
```
Graph Algorithms/
â”œâ”€â”€ ğŸ” Traversal Algorithms
â”‚   â”œâ”€â”€ bfs<T> (Breadth First Search)
â”‚   â”œâ”€â”€ dfs<T> (Depth First Search)
â”‚   â””â”€â”€ topologicalSort<T> (Topological sorting)
â”œâ”€â”€ ğŸ›£ï¸ Shortest Path Algorithms
â”‚   â”œâ”€â”€ dijkstra<T> (Dijkstra's algorithm)
â”‚   â”œâ”€â”€ bellmanFord<T> (Bellman-Ford algorithm)
â”‚   â”œâ”€â”€ floydWarshall<T> (Floyd-Warshall algorithm)
â”‚   â””â”€â”€ shortestPath<T> (Generic shortest path)
â”œâ”€â”€ ğŸŒ³ Tree & Forest Algorithms
â”‚   â”œâ”€â”€ mstKruskal<T> (Kruskal's MST algorithm)
â”‚   â”œâ”€â”€ mstPrim<T> (Prim's MST algorithm)
â”‚   â””â”€â”€ unionFind<T> (Union-Find data structure)
â”œâ”€â”€ ğŸ” Graph Analysis
â”‚   â”œâ”€â”€ connectedComponents<T> (Find connected components)
â”‚   â”œâ”€â”€ cycleDetection<T> (Detect cycles in graph)
â”‚   â”œâ”€â”€ articulationPoints<T> (Find articulation points)
â”‚   â”œâ”€â”€ kosarajuSCC<T> (Find strongly connected components)
â”‚   â””â”€â”€ bipartiteGraph<T> (Check if graph is bipartite)
â””â”€â”€ ğŸ”— Graph Components
    â””â”€â”€ WeightedEdge<T> (Weighted edge representation)
```

## ğŸ§ª Test Structure
```
Test Suite/
â”œâ”€â”€ ğŸŒ² Tree Algorithm Tests (NEW)
â”‚   â”œâ”€â”€ binary_tree_node_test.dart
â”‚   â”œâ”€â”€ tree_traversals_test.dart
â”‚   â”œâ”€â”€ level_order_traversal_test.dart
â”‚   â”œâ”€â”€ tree_depth_test.dart
â”‚   â”œâ”€â”€ invert_tree_test.dart
â”‚   â”œâ”€â”€ lowest_common_ancestor_test.dart
â”‚   â”œâ”€â”€ validate_bst_test.dart
â”‚   â”œâ”€â”€ tree_diameter_test.dart
â”‚   â”œâ”€â”€ balanced_tree_check_test.dart
â”‚   â”œâ”€â”€ tree_serialization_test.dart
â”‚   â””â”€â”€ zigzag_traversal_test.dart
â”œâ”€â”€ ğŸ”— Linked List Algorithm Tests (NEW)
â”‚   â”œâ”€â”€ linked_list_node_test.dart
â”‚   â”œâ”€â”€ doubly_linked_list_node_test.dart
â”‚   â”œâ”€â”€ insert_delete_at_position_test.dart
â”‚   â”œâ”€â”€ reverse_linked_list_test.dart
â”‚   â”œâ”€â”€ detect_cycle_test.dart
â”‚   â”œâ”€â”€ merge_sorted_lists_test.dart
â”‚   â”œâ”€â”€ remove_nth_from_end_test.dart
â”‚   â”œâ”€â”€ palindrome_linked_list_test.dart
â”‚   â””â”€â”€ intersection_of_lists_test.dart
â”œâ”€â”€ ğŸ“Š List Algorithm Tests
â”‚   â”œâ”€â”€ binary_search_test.dart
â”‚   â”œâ”€â”€ bubble_sort_test.dart
â”‚   â”œâ”€â”€ merge_sort_test.dart
â”‚   â”œâ”€â”€ quick_sort_test.dart
â”‚   â”œâ”€â”€ kadanes_algorithm_test.dart
â”‚   â””â”€â”€ [other list algorithm tests...]
â”œâ”€â”€ ğŸ—ºï¸ Map Algorithm Tests
â”‚   â”œâ”€â”€ two_sum_test.dart
â”‚   â”œâ”€â”€ anagram_checker_test.dart
â”‚   â”œâ”€â”€ frequency_count_test.dart
â”‚   â””â”€â”€ [other map algorithm tests...]
â”œâ”€â”€ ğŸ” Set Algorithm Tests
â”‚   â”œâ”€â”€ disjoint_set_test.dart
â”‚   â”œâ”€â”€ find_intersection_test.dart
â”‚   â””â”€â”€ [other set algorithm tests...]
â”œâ”€â”€ ğŸ“ String Algorithm Tests
â”‚   â”œâ”€â”€ palindrome_checker_test.dart
â”‚   â”œâ”€â”€ kmp_search_test.dart
â”‚   â”œâ”€â”€ edit_distance_test.dart
â”‚   â””â”€â”€ [other string algorithm tests...]
â”œâ”€â”€ ğŸ•¸ï¸ Graph Algorithm Tests
â”‚   â”œâ”€â”€ bfs_test.dart
â”‚   â”œâ”€â”€ dfs_test.dart
â”‚   â”œâ”€â”€ dijkstra_test.dart
â”‚   â”œâ”€â”€ mst_test.dart
â”‚   â””â”€â”€ [other graph algorithm tests...]
â””â”€â”€ ğŸ“š Main Library Test
    â””â”€â”€ algorithms_core_test.dart
```

## ğŸ“š Examples Structure
```
Examples/
â”œâ”€â”€ ğŸ“š Main Example
â”‚   â””â”€â”€ algorithms_core_example.dart (Comprehensive library tour)
â”œâ”€â”€ ğŸŒ² Tree Algorithms Example (NEW)
â”‚   â””â”€â”€ tree_algorithms_example.dart (All tree algorithm demonstrations)
â””â”€â”€ ğŸ”— Linked List Algorithms Example (NEW)
    â””â”€â”€ linked_list_algorithms_example.dart (All linked list algorithm demonstrations)
```

## ğŸ”§ Technical Features

### ğŸ¯ Generic Type Support
- **All algorithms** support generic type `T`
- **Comparable algorithms** use `T extends Comparable<T>`
- **Type-safe operations** throughout the library

### ğŸ“š Documentation Standards
- **Dartdoc comments** for all public functions
- **Time complexity** analysis (Big O notation)
- **Space complexity** analysis
- **Usage examples** in documentation
- **Emoji indicators** for visual organization

### ğŸ§ª Testing Coverage
- **Unit tests** for all algorithms
- **Edge cases** covered (empty inputs, single elements, etc.)
- **Generic type testing** with different data types
- **Comprehensive scenarios** for complex algorithms

### ğŸš€ Performance Characteristics
- **Optimized implementations** suitable for production use
- **Efficient algorithms** following best practices
- **Memory-conscious** implementations
- **Scalable solutions** for large datasets

### ğŸ”Œ Integration Features
- **Single import** access to all algorithms
- **Consistent API** design across all categories
- **Conflict resolution** for naming overlaps
- **Modular architecture** for easy maintenance

## ğŸŒŸ Library Highlights

### âœ¨ **NEWEST ADDITIONS**
- **Tree Algorithms**: Complete binary tree manipulation suite
- **Linked List Algorithms**: Comprehensive linked list operations
- **Advanced Data Structures**: Generic, production-ready implementations

### ğŸ† **Production Quality**
- **Company-ready code** with enterprise-level standards
- **Comprehensive testing** with 100% algorithm coverage
- **Professional documentation** following industry best practices
- **Performance optimized** for real-world applications

### ğŸ”„ **Continuous Evolution**
- **Regular updates** with new algorithm categories
- **Backward compatibility** maintained across versions
- **Community-driven** development approach
- **Open source** with MIT license

---

*This tree represents the complete structure of the algorithms core Library as of the latest update. The library continues to grow with new algorithm categories and implementations.* ğŸŒ±
